package algo;


public class Chapter5 {
	
	static final class Node<T> // node object 
	{
		T value;
		Node<T> next;
		
		Node(T val)
		{
			this.value = val;
			next = null;
		}
	}
	
	static final class  List<T> 
	{
	
		
		final Node<T> addFront(Node<T> ptr, T value) 
		{
			Node<T> node = new Node<T>(value);
			
			if (ptr != null) 
			{
				node.next = ptr;
			}
			
			return node;
		}
		
		final boolean contains (Node<T> ptr, T val)
		{
			while (ptr != null) 
			{
				if (ptr.value == val)
				{
					return true;
				}
			}
			return false;
		}
		
		final Node<T> removeFront (Node<T> ptr) 
		{
			if (ptr != null) 
			{
				ptr = ptr.next;
			}
			return ptr;
		}
		
		final T front(Node<T> ptr) 
		{
			if (ptr != null) 
			{
				return ptr.value;
			}
			return null;
		}
		
		final int length (Node<T> ptr) 
		{
			int count = 0;
			while (ptr != null) 
			{
				count++;
				ptr = ptr.next;
			}
			return count;
		}
		
		final T max(Node<T> ptr) 
		{
			T result = null;
			String[] v = new String[2];
			
			while (ptr != null) 
			{
				if (result == null) 
				{
					result = ptr.value;
				}
				
				else 
				{
					v[0] = String.valueOf( ptr.value);
					v[1] = String.valueOf( result);
					
					if (result instanceof String) 
					{
						if (v[0].compareTo(v[1]) > 0)
						{
							result = ptr.value;
						}
					}
					
					if (result instanceof Number) 
					{
						if (Integer.valueOf(v[0])  >  Integer.valueOf( v[1]) )
						{
							result = ptr.value;
						}
					}
				}
				ptr = ptr.next;
			}
				
			return result;
		}
		
		final T min(Node<T> ptr) 
		{
			T result = null;
			String[] v = new String[2];
			
			while (ptr != null) 
			{
				if (result == null) 
				{
					result = ptr.value;
				}
				
				else 
				{
					v[0] = String.valueOf( ptr.value);
					v[1] = String.valueOf( result);
					
					if (result instanceof String) 
					{
						if (v[0].compareTo(v[1]) < 0)
						{
							result = ptr.value;
						}
					}
					
					if (result instanceof Number) 
					{
						if (Integer.valueOf(v[0])  <  Integer.valueOf( v[1]) )
						{
							result = ptr.value;
						}
					}
				}
				ptr = ptr.next;
			}
				
			return result;
		}
		
		final Number average (Node<T> ptr) 
		{
			double sum = 0;
			int  n = 0;
			
			if (ptr == null) 
			{
				return null;
			}
			if ( ! (ptr.value instanceof Number) ) 
			{
				return null;
			}
			while (ptr != null) 
			{
				n++;
				sum += Double.valueOf( String.valueOf( ptr.value) );
				ptr = ptr.next;
			}
			if (n!=0) 
			{
				return sum / (double) n;
			}
			return null;
		}
		
		final void display(Node<T> ptr) 
		{
			while (ptr != null) 
			{
				System.out.print(String.valueOf(ptr.value) + ',');
				ptr = ptr.next; 
			}
			System.out.println("");
		}
		
		final T back(Node<T> ptr) 
		{
			if (ptr != null) 
			{
				while (ptr.next != null) 
				{
					ptr = ptr.next; 
				}
				return ptr.value;
			}
			return null;
		}
		
		final Node<T> removeBack (Node<T> ptr) 
		{
			if (ptr != null) 
			{
				if (ptr.next != null) 
				{
					while (ptr.next.next != null)
					{
						ptr = ptr.next;
					}
					
					ptr.next = null;
				}
			}
			return null;
		}
		
		final void addBack (Node<T> ptr, T value) 
		{
			
			if (ptr == null) 
			{
				addFront(ptr, value);
			}
			
			if (ptr != null) 
			{
				while (ptr.next != null )
				{
					ptr = ptr.next;
				}
				ptr.next = new Node<T>(value);
			}
		}
	
		interface compareInterface<T>
		{
			boolean compare(Node<T> a, Node<T> b);	
			default void normalFunction ()
			{
				System.out.println("Thanks for using interface");
			}
		}
		
		final Node<T> moveToFront (Node<T> ptr, int mode) 
		{
			Node<T> head, oldHead, prev = null;
			compareInterface<T> interfaceSelect;
			
			if (ptr == null)
			{
				return null;
			}
			
			oldHead = head = ptr;

			while (ptr.next != null) 
			{
				switch(mode) 
				{
						
					case 0: 
						interfaceSelect = (Node<T>  curr,  Node<T> min) -> {
							return Double.valueOf( String.valueOf(curr.value)).compareTo(Double.valueOf( String.valueOf(min.value)) ) < 0;
						};
					break;
					
					case 1:  
						interfaceSelect = (Node<T>  curr,  Node<T> max) -> {
							return Double.valueOf( String.valueOf(curr.value)).compareTo(Double.valueOf( String.valueOf(max.value)) ) > 0;
						};
						break;
					
					default:
						return null;
				}
				
				if (interfaceSelect.compare(ptr.next, head))
				{
					head = ptr.next;
					prev = ptr;
				}
			
				ptr = ptr.next;
			}
			
			
			if (prev != null) 
			{
				prev.next = prev.next.next;
				head.next = oldHead;
			}
		
			return head;		
		}
		
		final Node<T> moveMinToFront(Node<T> ptr)
		{

			return moveToFront(ptr, 0);
		}
		
		final Node<T> moveMaxToFront(Node<T> ptr)
		{
			
			return moveToFront(ptr, 1);
		}
		
		final Node<T> prependVal(Node<T> ptr, T value, T before) 
		{
			Node<T> oldHead = ptr, node = new Node<T>(value);
			
			if (ptr == null) 
			{
				return node;
			}
			
			if (ptr.value  == before) 
			{
				node.next = ptr;
				return node;
			}
			
			while (ptr.next != null) 
			{
				if (ptr.next.value == before) 
				{
					node.next= ptr.next;
					ptr.next = node;
					ptr = node;
				}
				ptr = ptr.next;
			}
			
			if (node.next == null) // node not added to list
			{
				ptr.next = node;
			}
			
			return oldHead;
		}
		
		
		
		final Node<T> appendVal(Node<T> ptr, T value, T after) 
		{
			Node<T> oldHead = ptr, node = new Node<T>(value);
			
			if (ptr == null) 
			{
				return node;
			}
			
			if (ptr.value  == after) 
			{
				node.next = ptr.next;
				ptr.next = node;
				return ptr;
			}
			
			while (ptr.next != null) 
			{
				if (ptr.next.value == after) 
				{
					node.next= ptr.next.next;
					ptr.next.next = node;
					ptr = node;
				}
				ptr = ptr.next;
			}
			
			if (node.next == null) // node not added to list
			{
				ptr.next = node;
			}
			
			return oldHead;
		}
		
		final Node<T> removeVal(Node<T> ptr, T value)
		{
			Node<T> newHead = ptr, marker;
			
			if (ptr == null)
			{
				return null;
			}
			
			while (ptr != null) // check front for value
			{
				if (ptr.value != value) 
				{
					break;
				}
				newHead = ptr = ptr.next;
			}
			
			if (ptr != null)
			{
				while (ptr.next != null) 
				{
					if (ptr.next.value == value) 
					{
						ptr.next = ptr.next.next;
					}
					else
					{
						ptr = ptr.next;
					}
				}
			}
			return newHead;
		}
		
		final Node<T> splitOnValue (Node<T> ptr, T value) 
		{
			Node<T> newHead = null;
			
			if (ptr == null) 
			{
				return null;
			}
			
			
			if (ptr.value == value)
			{
				return ptr;
			}
			
			while (ptr.next != null) 
			{
				if (ptr.next.value == value) 
				{
					newHead = ptr.next;
					ptr.next = null;
				}
				else 
				{
					ptr = ptr.next;
				}
				
			}
			return newHead;
		}
		
		final Node<T> concat (Node<T> a, Node<T> b) 
		{
			Node<T> head = null;
			
			if (a == null) 
			{
				return b;
			}
			
			if (b == null) 
			{
				return a;
			}
			
			while (a.next != null) 
			{
				a = a.next;
			}
			
			a.next = b;
			
			return head;
		}
		
		final Node<T> removeNegatives (Node<T> ptr) 
		{
			Node<T> head = null;
			
			if (ptr == null) 
			{
				return null;
			}
			
			while (ptr != null)
			{
				if (Double.valueOf(String.valueOf(ptr.value)) >= 0)
				{
					break;
				}
				head = ptr = ptr.next;
			}
			
			while (ptr.next != null) 
			{
				if (Double.valueOf(String.valueOf(ptr.next.value)) < 0) 
				{
					ptr.next = ptr.next.next;
				}
				else 
				{
					ptr = ptr.next;
				}
			}
			
			return head;
		}
		
		final Node<T> partition (Node<T> ptr, T value)  // partition(S) sorted 
		{
			Node<T> head = null, part = null, partClone = null, nde;
			int ptrNextValue, ptrValue , valuePart;
			
			if (ptr == null)
			{
				return null;
			}
			
			head = ptr;
			valuePart = Integer.valueOf(String.valueOf(value));
			
			while (ptr.next != null) 
			{
				ptrNextValue = Integer.valueOf(String.valueOf(ptr.next.value));
				ptrValue = Integer.valueOf(String.valueOf(ptr.value));

						
				if (ptrNextValue < valuePart )  // less than value 
				{
					nde = ptr.next;
					ptr.next = ptr.next.next;
					
					nde.next = head; 
					head = nde;
				}
				else if (ptrNextValue == valuePart)
				{
					if (part == null)
					{

						partClone = part = ptr = ptr.next;	
					}
					else if (ptrNextValue == ptrValue) // prev.value == next.value = partition.value
					{
						partClone = ptr = ptr.next;			
					}
					else 
					{
						nde = ptr.next;
						ptr.next = ptr.next.next;
						
						// append after part(partition) node clone(s)
						nde.next = partClone.next;
						partClone = partClone.next = nde;		
					}
				}
				
				else 
				{
					ptr = ptr.next;
				}
				
			}
			
			return head;
		}
		
		final T secondToLastValue(Node<T> ptr) 
		{
			
			if (ptr == null) 
			{
				return null;
			}
			
			if (ptr.next != null) 
			{
				if (ptr.next.next != null) 
				{
					while (ptr.next.next != null) 
					{
						ptr = ptr.next;
					}
					return ptr.value;
				}
			}
			return null;
		}
		
		final void removeSelf(Node<T> ptr) 
		{
			if (ptr == null) 
			{
				return;
			}
			
			if (ptr.next == null) 
			{
				return;
			}
			
			ptr.value = ptr.next.value;
			ptr.next = ptr.next.next;
		}
		
		final Node<T> copy (Node<T> ptr)  // deep copy
		{
			Node<T> head = null, tail = null;
			
			while (ptr != null)
			{
				if (head == null) 
				{
					tail = head = new Node<T>(ptr.value);
				}
				else 
				{
					tail = tail.next =  new Node<T>(ptr.value);
				}
				ptr = ptr.next;
			}
			
			return head;
		}
		
		final Node<T> filter (Node<T> ptr, int low, int high) 
		{
			int ptrValue;
			Node<T> head; 
			
			if (ptr == null) 
			{
				return null;
			}
			
			head = ptr;
			
			while (ptr != null) 
			{
				ptrValue = Integer.valueOf(String.valueOf(ptr.value));
				if ( ptrValue >= low && ptrValue <=high ) // valid node found break loop
				{
					break;
				}
				head = ptr = ptr.next;
			}
			
			while (ptr.next != null) 
			{
				ptrValue = Integer.valueOf(String.valueOf(ptr.next.value));
				if ( ptrValue < low || ptrValue > high ) 
				{

					ptr.next = ptr.next.next;
				}
				else 
				{
					ptr = ptr.next;
				}
			}
			
			return head;
		}
		
		final T secondLargestValue ( Node<T> ptr) 
		{
			Object[] maxReg = new Object[2];
			
			compareInterface<T> cmprInterface = (Node<T>  a,  Node<T> b) -> {
				if (a == null || b == null) 
				{
					return false;
				}
				return Double.valueOf( String.valueOf(a.value))  >  Double.valueOf( String.valueOf(b.value)  );
			};
				
			while (ptr != null) 
			{
				if (maxReg[1] == null) 
				{
					maxReg[1] = ptr;
				}
				
				if (cmprInterface.compare(ptr, (Node<T>) maxReg[1]))  // cast maxReg[1]!
				{
					maxReg[0] = maxReg[1];
					maxReg[1] = ptr;
				}
				else if (cmprInterface.compare(ptr, (Node<T>) maxReg[0])) // cast maxReg[0]!
				{
					maxReg[0] = ptr;
			
				}
				ptr = ptr.next;
			}
			
			if (maxReg[1] != null)
			{
				return  ((Node<T>)maxReg[1]).value;				
			}
			
			return null;
		}
		
		final Node<T> zip (Node<T> ptrA, Node<T> ptrB) 
		{
			Node<T> ptrAHead = null, ptrBNext = null;
			
			if (ptrA == null) 
			{
				return ptrB;
			}
			ptrAHead = ptrA;
			while (ptrA.next != null && ptrB != null) 
			{
				ptrBNext = ptrB.next;
				ptrB.next = ptrA.next;
				ptrA.next = ptrB;
				ptrB = ptrBNext; // one step forward in B list  
				ptrA = ptrA.next.next; //note* ptrA.next is inserted B element
			}
			
			while (ptrA.next != null) // move to last node in A list
			{
				ptrA = ptrA.next;
			}
			
			ptrA.next = ptrB; // append remaining 
			
			return ptrAHead;
		}
		
		final void dedupe(Node<T> ptr) 
		{
			Node<T> bufferHead, bufferTail, bufferptr;
			
			compareInterface<T> cmprInterface = (Node<T>  a,  Node<T> b) -> {
				if (a == null || b == null) 
				{
					return false;
				}
				return Double.valueOf( String.valueOf(a.value)).compareTo(Double.valueOf( String.valueOf(b.value)) ) == 0;
			};
			
			if (ptr == null) 
			{
				return;
			}
			
	
			bufferHead = bufferTail = new Node<T>(ptr.value);
			
			while (ptr.next != null) 
			{
				bufferptr = bufferHead;     

				while (bufferptr != null)   // search for dup
				{
					if (cmprInterface.compare(ptr.next, bufferptr))
					{
						break;
					}
					bufferptr = bufferptr.next;
				}
				
				if (bufferptr != null)  // remove ptr.next
				{
					display(bufferptr);

					ptr.next = ptr.next.next;
				}
				else 
				{
					ptr = ptr.next;
					bufferTail = bufferTail.next = new Node<T>(ptr.value);

				}
			}
		}
		
		final void dedupeWithOutBuffer(Node<T> ptr)   // NLogN runtime
		{
			Node<T> walk;
			compareInterface<T> cmprInterface = (Node<T>  a,  Node<T> b) -> {
				if (a == null || b == null) 
				{
					return false;
				}
				return Double.valueOf( String.valueOf(a.value)).compareTo(Double.valueOf( String.valueOf(b.value)) ) == 0;
			};
			
			while (ptr.next != null) 
			{
				walk  = ptr;
				while (walk.next != null)   // search for dups 
				{
					if (cmprInterface.compare(ptr, walk.next))   // dup!
					{
						walk.next  = walk.next.next;  // remove!
					}
					else 
					{
						walk = walk.next;    // walk
					}
				}
				ptr = ptr.next; // move ptr forward 
			}
			
		}


	}

	public static void main (String[] args)
	{
		List<Integer> w = new List<Integer>();
		Node<Integer> head = null, head2;
		head = w.addFront(head, -1);
		head = w.addFront(head, 2);
		head = w.addFront(head, 3);
		head = w.addFront(head, -20);
		head = w.addFront(head, -9);
		head = w.addFront(head, 4000);
		head = w.addFront(head, 56);
		head = w.addFront(head, 2);
		head = w.addFront(head, 9);
		head = w.addFront(head, 5);

		head = w.moveMaxToFront(head);
		head = w.prependVal(head, 100, -100);
		
//		head = w.appendVal(head,  120, -9);
		head2 = w.splitOnValue(head,  -9);

//		head = w.partition(head, 2);
//		head = w.copy(head);
		
		w.display(head);
		w.display(head2);
		head = w.zip(head, head2);
		
		System.out.println("");
		w.display(head);
		
		w.dedupeWithOutBuffer(head);
		w.display(head);


	}

}
